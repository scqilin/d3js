<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>d3.js basic chart</title>
    <script src="../js/d3.min.js"></script>
    <!-- <script src="https://d3js.org/d3.v6.min.js"></script> -->
    <style>
        button {
            margin: 0 8px;
        }

        body {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
        }

        body>div {
            margin: 24px;
        }
    </style>
</head>

<body>
    <h3 style="width: 100%;">
        <a href="https://github.com/scqilin/d3js" target="_blank">Github 源码</a>
    </h3>
    <!-- 
        代码为什么看起来重复度那么高？
        因为我把很多案例放在一个页面里面，方便对比，实际使用中，可以提取复用的部分，比如：svg 容器，坐标轴，数据等等……
        从而减少代码量，提高开发效率。
        代码为什么废话那么多？因为我想写，我想写，我想写，重要的事情说三遍。
        把思路写出来，让你知道我是怎么想的，这样你就可以自己写了。
    -->
    <script>
        /**
         * author: scqilin
         * date: 2023-06-12
         * QQ群: 959261248
         */
        console.log('人们因技术发展得以更好地掌控时间，但也有人因此成了时问的仆人。');
        (function () {
            // div 容器
            let dom = document.createElement('div');
            document.body.appendChild(dom);
            // 基本柱状图
            let dataset = [
                { name: "1", value: 30 },
                { name: "2", value: 20 },
                { name: "3", value: 50 },
                { name: "4", value: 20 },
                { name: "5", value: 100 },
                { name: "6", value: 30 },
                { name: "7", value: 60 }
            ];

            let padding = 30;
            let svgWidth = 600;
            let svgHeight = 400;

            let xScale = d3.scaleBand()
                .domain(d3.range(dataset.length))
                .range([padding, svgWidth - padding])
                .padding(0.3)

            let yScale = d3.scaleLinear()
                .domain([0, d3.max(dataset, function (d) { return d.value; })])
                .range([svgHeight - padding, padding]);

            let svg = d3.select(dom)
                .append("svg")
                .attr("width", svgWidth)
                .attr("height", svgHeight)
                .style('border', '1px solid #999999')


            let barWidth = xScale.bandwidth();
            let bars = svg.selectAll(".bar")
                .data(dataset)
                .join('rect')
                .attr("class", "bar")
                .attr("fill", "#69b3a2")
                .attr("x", function (d, i) {
                    return xScale(i);
                })
                .attr("y", function (d) {
                    return yScale(d.value);
                })
                .attr("width", barWidth)
                .attr("height", function (d) {
                    return svgHeight - yScale(d.value) - padding;
                });


            let xAxis = d3.axisBottom(xScale)
                .tickFormat(function (d, i) {
                    return dataset[i].name;
                })
            let yAxis = d3.axisLeft(yScale);

            svg.append("g")
                .attr("class", "x-axis")
                .attr("transform", "translate(0," + (svgHeight - padding) + ")")
                .call(xAxis);

            svg.append("g")
                .attr("class", "y-axis")
                .attr("transform", "translate(" + padding + ",0)")
                .call(yAxis);

            // 添加按钮 更新数据 
            let butdiv = document.createElement('div');
            dom.appendChild(butdiv);
            let but1 = document.createElement('button');
            but1.innerHTML = '更新数据';
            butdiv.appendChild(but1);
            but1.onclick = function () {
                dataset.forEach(function (d) {
                    d.value = Math.floor(Math.random() * 90) + 10;
                });
                svg.selectAll(".bar")
                    .data(dataset)
                    .join('rect')
                    .transition()
                    .duration(1000)
                    .attr("y", function (d) {
                        return yScale(d.value);
                    })
                    .attr("height", function (d) {
                        return svgHeight - yScale(d.value) - padding;
                    });
            }
            // 添加按钮 正向排序
            let but2 = document.createElement('button');
            but2.innerHTML = '正向排序';
            butdiv.appendChild(but2);
            but2.onclick = function () {
                dataset.sort(function (a, b) {
                    return a.value - b.value;
                });
                xScale.domain(d3.range(dataset.length));
                svg.selectAll(".bar")
                    .data(dataset)
                    .join('rect')
                    .transition()
                    .duration(1000)
                    .attr("x", function (d, i) {
                        return xScale(i);
                    })
                    .attr("y", function (d) {
                        return yScale(d.value);
                    })
                    .attr("height", function (d) {
                        return svgHeight - yScale(d.value) - padding;
                    });
            }
            // 添加按钮 反向排序
            let but3 = document.createElement('button');
            but3.innerHTML = '反向排序';
            butdiv.appendChild(but3);
            but3.onclick = function () {
                dataset.sort(function (a, b) {
                    return b.value - a.value;
                });
                xScale.domain(d3.range(dataset.length));
                svg.selectAll(".bar")
                    .data(dataset)
                    .join('rect')
                    .transition()
                    .duration(1000)
                    .attr("x", function (d, i) {
                        return xScale(i);
                    })
                    .attr("y", function (d) {
                        return yScale(d.value);
                    })
                    .attr("height", function (d) {
                        return svgHeight - yScale(d.value) - padding;
                    });
            }

            // 添加按钮 添加数据
            let but4 = document.createElement('button');
            but4.innerHTML = '添加数据';
            butdiv.appendChild(but4);
            but4.onclick = function () {
                let newNum = Math.floor(Math.random() * 90) + 10;
                dataset.push({ name: dataset.length + 1, value: newNum });
                xScale.domain(d3.range(dataset.length));
                // 更新x轴
                svg.select(".x-axis")
                    .transition()
                    .duration(1000)
                    .call(xAxis);
                // 更新柱子
                barWidth = xScale.bandwidth();
                svg.selectAll(".bar")
                    .data(dataset)
                    .join('rect')
                    .attr("class", "bar")
                    .attr("fill", "#69b3a2")
                    .attr("x", function (d, i) {
                        return xScale(i);
                    })
                    .attr("width", barWidth)
                    .transition()
                    .duration(1000)
                    .attr("y", function (d) {
                        return yScale(d.value);
                    })
                    .attr("height", function (d) {
                        return svgHeight - yScale(d.value) - padding;
                    });

            }

            // 添加按钮 删除数据
            let but5 = document.createElement('button');
            but5.innerHTML = '删除数据';
            butdiv.appendChild(but5);
            but5.onclick = function () {
                if (dataset.length <= 7) return;
                // 删除最后一项
                dataset.pop();
                xScale.domain(d3.range(dataset.length));
                // 更新x轴
                svg.select(".x-axis")
                    .transition()
                    .duration(1000)
                    .call(xAxis);
                // 更新柱子
                barWidth = xScale.bandwidth();
                svg.selectAll(".bar")
                    .data(dataset)
                    .join('rect')
                    .attr("class", "bar")
                    .attr("fill", "#69b3a2")
                    .attr("x", function (d, i) {
                        return xScale(i);
                    })
                    .attr("width", barWidth)
                    .transition()
                    .duration(1000)
                    .attr("y", function (d) {
                        return yScale(d.value);
                    })
                    .attr("height", function (d) {
                        return svgHeight - yScale(d.value) - padding;
                    });
            }
        })();


    </script>

    <script>
        (function () {
            let dom = document.createElement('div');
            document.body.appendChild(dom);
            // 基本折线图
            let dataset = [
                { name: "苹果", value: 50 },
                { name: "橙子", value: 30 },
                { name: "香蕉", value: 70 },
                { name: "核桃", value: 20 },
                { name: "芒果", value: 60 },
                { name: "梨子", value: 100 },
                { name: "菠萝", value: 80 },
                { name: "葡萄", value: 90 },
                { name: "草莓", value: 35 },
                { name: "西瓜", value: 75 },
                { name: "桃子", value: 55 },
                { name: "樱桃", value: 25 }
            ];

            let padding = 30;
            let svgWidth = 600;
            let svgHeight = 400;

            let xScale = d3.scaleBand()
                .domain(d3.range(dataset.length))
                .range([padding, svgWidth - padding])
                .padding(0) // 设置柱子之间的间隙
                .paddingInner(1) // 设置柱子内部的间隙

            let yScale = d3.scaleLinear()
                .domain([0, d3.max(dataset, function (d) { return d.value; })])
                .range([svgHeight - padding, padding]);

            let svg = d3.select(dom)
                .append("svg")
                .attr("width", svgWidth)
                .attr("height", svgHeight)
                .style('border', '1px solid #999999')


            let line = d3.line()
                .x(function (d, i) {
                    return xScale(i) + xScale.bandwidth() / 2;
                })
                .y(function (d) {
                    return yScale(d.value);
                })
                .curve(d3.curveCardinal);

            svg.append("path")
                .datum(dataset)
                .attr("class", "line")
                .attr("d", line)
                .attr("fill", "none")
                .attr("stroke", "#69b3a2")
                .attr("stroke-width", "3px");

            let xAxis = d3.axisBottom(xScale)
                .tickFormat(function (d, i) {
                    return dataset[i].name;
                })
            let yAxis = d3.axisLeft(yScale);

            svg.append("g")
                .attr("class", "x-axis")
                .attr("transform", "translate(0," + (svgHeight - padding) + ")")
                .call(xAxis);

            svg.append("g")
                .attr("class", "y-axis")
                .attr("transform", "translate(" + padding + ",0)")
                .call(yAxis);

            //更新数据
            let innerHtml = ['更新数据', '正向排序', '反向排序', '添加数据', '删除数据'];
            let buts = [];
            let butdiv = document.createElement('div');
            dom.appendChild(butdiv);
            innerHtml.map(item => {
                let but = document.createElement('button');
                but.innerHTML = item;
                butdiv.appendChild(but);
                buts.push(but);
            })
            buts[0].onclick = function () {
                dataset.forEach(function (d) {
                    d.value = Math.floor(Math.random() * 80) + 20;
                });
                svg.selectAll(".line")
                    .data([dataset])
                    .transition()
                    .duration(1000)
                    .attr("d", line);
            }

            buts[1].onclick = function () {
                dataset.sort(function (a, b) {
                    return a.value - b.value;
                });
                xScale.domain(d3.range(dataset.length));
                // 更新x轴
                svg.select(".x-axis")
                    .transition()
                    .duration(1000)
                    .call(xAxis);
                // 更新折线
                svg.selectAll(".line")
                    .data([dataset])
                    .transition()
                    .duration(1000)
                    .attr("d", line);
            }

            buts[2].onclick = function () {
                dataset.sort(function (a, b) {
                    return b.value - a.value;
                });
                xScale.domain(d3.range(dataset.length));
                // 更新x轴
                svg.select(".x-axis")
                    .transition()
                    .duration(1000)
                    .call(xAxis);
                // 更新折线
                svg.selectAll(".line")
                    .data([dataset])
                    .transition()
                    .duration(1000)
                    .attr("d", line);
            }

            buts[3].onclick = function () {
                let newNum = Math.floor(Math.random() * 80) + 20;
                dataset.push({ name: "新来的", value: newNum });
                xScale.domain(d3.range(dataset.length));
                // 更新x轴
                svg.select(".x-axis")
                    .transition()
                    .duration(1000)
                    .call(xAxis);
                // 更新折线
                svg.selectAll(".line")
                    .data([dataset])
                    .transition()
                    .duration(1000)
                    .attr("d", line);
            }

            buts[4].onclick = function () {
                if (dataset.length <= 3) {
                    return;
                }
                dataset.pop();
                xScale.domain(d3.range(dataset.length));
                // 更新x轴
                svg.select(".x-axis")
                    .transition()
                    .duration(1000)
                    .call(xAxis);
                // 更新折线
                svg.selectAll(".line")
                    .data([dataset])
                    .transition()
                    .duration(1000)
                    .attr("d", line);
            }
            /**
             * 最后我们添加5个按钮，来执行 '更新数据', '正向排序', '反向排序', '添加数据', '删除数据'等操作。
             * 更新数据的时候，我们只需要更新数据集dataset，然后再次调用line函数，就可以更新折线了。
             * 排序的时候，我们需要对数据集dataset进行排序，然后再次调用xScale.domain()函数，更新x轴的定义域，再次调用xAxis函数，更新x轴。
             * 添加数据的时候，我们只需要向数据集dataset中添加一个新的数据，然后再次调用xScale.domain()函数，更新x轴的定义域，再次调用xAxis函数，更新x轴。
             * 删除数据的时候，我们只需要从数据集dataset中删除一个数据，然后再次调用xScale.domain()函数，更新x轴的定义域，再次调用xAxis函数，更新x轴。
             * 
             * /
        }())



    </script>

    <script>
            (function () {
                let dom = document.createElement('div');
                document.body.appendChild(dom);
                // 基本面积图
                let dataset = [
                    { name: "苹果", value: 50 },
                    { name: "橙子", value: 30 },
                    { name: "香蕉", value: 70 },
                    { name: "核桃", value: 20 },
                    { name: "芒果", value: 60 },
                    { name: "梨子", value: 100 },
                    { name: "菠萝", value: 80 },
                    { name: "葡萄", value: 90 },
                    { name: "草莓", value: 35 },
                    { name: "西瓜", value: 75 },
                    { name: "桃子", value: 55 },
                    { name: "樱桃", value: 25 }
                ];

                let padding = 30;
                let svgWidth = 600;
                let svgHeight = 400;

                let xScale = d3.scaleBand()
                    .domain(d3.range(dataset.length))
                    .range([padding, svgWidth - padding])
                    .padding(0)
                    .paddingInner(1)

                let yScale = d3.scaleLinear()
                    .domain([0, d3.max(dataset, function (d) { return d.value; })])
                    .range([svgHeight - padding, padding]);

                let area = d3.area()
                    .x(function (d, i) { return xScale(i) + xScale.bandwidth() / 2; })
                    .y0(svgHeight - padding)
                    .y1(function (d) { return yScale(d.value); })
                    .curve(d3.curveCardinal);

                let svg = d3.select(dom)
                    .append("svg")
                    .attr("width", svgWidth)
                    .attr("height", svgHeight)
                    .style('border', '1px solid #999999')

                svg.append("path")
                    .datum(dataset)
                    .attr("class", "area")
                    .attr("d", area)
                    .attr("fill", "#69b3a2");

                let xAxis = d3.axisBottom(xScale)
                    .tickFormat(function (d, i) { return dataset[i].name; });
                let yAxis = d3.axisLeft(yScale);

                svg.append("g")
                    .attr("class", "x-axis")
                    .attr("transform", "translate(0," + (svgHeight - padding) + ")")
                    .call(xAxis);

                svg.append("g")
                    .attr("class", "y-axis")
                    .attr("transform", "translate(" + padding + ",0)")
                    .call(yAxis);
                //更新数据
                let innerHtml = ['更新数据', '正向排序', '反向排序', '添加数据', '删除数据'];
                let buts = [];
                let butdiv = document.createElement('div');
                dom.appendChild(butdiv);
                innerHtml.map(item => {
                    let but = document.createElement('button');
                    but.innerHTML = item;
                    butdiv.appendChild(but);
                    buts.push(but);
                })

                buts[0].onclick = function () {
                    dataset.forEach(function (d) {
                        d.value = Math.floor(Math.random() * 90) + 10;
                    });
                    svg.selectAll(".area")
                        .data([dataset])
                        .transition()
                        .duration(1000)
                        .attr("d", area);
                }

                buts[1].onclick = function () {
                    dataset.sort(function (a, b) {
                        return d3.ascending(a.value, b.value);
                    });
                    xScale.domain(d3.range(dataset.length));
                    // 更新x轴
                    svg.select(".x-axis")
                        .transition()
                        .duration(1000)
                        .call(xAxis);
                    // 更新面积图
                    svg.selectAll(".area")
                        .data([dataset])
                        .transition()
                        .duration(1000)
                        .attr("d", area);
                }

                buts[2].onclick = function () {
                    dataset.sort(function (a, b) {
                        return d3.descending(a.value, b.value);
                    });
                    xScale.domain(d3.range(dataset.length));
                    // 更新x轴
                    svg.select(".x-axis")
                        .transition()
                        .duration(1000)
                        .call(xAxis);
                    // 更新面积图
                    svg.selectAll(".area")
                        .data([dataset])
                        .transition()
                        .duration(1000)
                        .attr("d", area);
                }

                buts[3].onclick = function () {
                    let newdata = { name: "新来的", value: Math.floor(Math.random() * 90) + 10 };
                    dataset.push(newdata);
                    xScale.domain(d3.range(dataset.length));
                    // 更新x轴
                    svg.select(".x-axis")
                        .transition()
                        .duration(1000)
                        .call(xAxis);
                    // 更新面积图
                    svg.selectAll(".area")
                        .data([dataset])
                        .transition()
                        .duration(1000)
                        .attr("d", area);
                }

                buts[4].onclick = function () {
                    if (dataset.length <= 3) {
                        return;
                    }
                    dataset.pop();
                    xScale.domain(d3.range(dataset.length));
                    // 更新x轴
                    svg.select(".x-axis")
                        .transition()
                        .duration(1000)
                        .call(xAxis);
                    // 更新面积图
                    svg.selectAll(".area")
                        .data([dataset])
                        .transition()
                        .duration(1000)
                        .attr("d", area);
                }

            })()

    </script>
    <script>
            (function () {
                let dom = document.createElement('div');
                document.body.appendChild(dom);
                // 基本饼图
                let dataset = [
                    { name: "春", value: 20 },
                    { name: "夏", value: 50 },
                    { name: "秋", value: 20 },
                    { name: "冬", value: 80 }
                ];

                // 颜色集合 24个
                let color = d3.scaleOrdinal(["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3",
                    "#a6d854", "#ffd92f", "#e5c494", "#b3b3b3",
                    "#8dd3c7", "#ffffb3", "#bebada", "#fb8072",
                    "#80b1d3", "#fdb462", "#b3de69", "#fccde5",
                    "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f",
                    "#1f78b4", "#33a02c", "#cab2d6", "#6a3d9a"]);

                // SVG尺寸
                let svgWidth = 600;
                let svgHeight = 400;

                // 饼图半径
                let radius = Math.min(svgWidth, svgHeight) / 3;

                // 创建一个弧生成器
                let arcGenerator = d3.arc()
                    .innerRadius(radius * 0.5)
                    .outerRadius(radius);

                // 创建一个布局
                let pieLayout = d3.pie()
                    .sort(null) // 不排序，按照数据的顺序
                    .value(function (d) {
                        return d.value;
                    });

                // 生成饼图数据
                let pieData = pieLayout(dataset);

                // 创建SVG容器
                let svg = d3.select(dom)
                    .append("svg")
                    .attr("width", svgWidth)
                    .attr("height", svgHeight)
                    .style('border', '1px solid #999999');

                // 创建饼图容器并居中显示
                let pieContainer = svg.append("g")
                    .attr("transform", "translate(" + svgWidth / 2 + "," + svgHeight / 2 + ")");

                // 绘制饼图
                let piePaths = pieContainer.selectAll(".arc")
                    .data(pieData)
                    .join("path")
                    .attr("class", "arc")
                    .attr("d", arcGenerator)
                    .attr("fill", function (d, i) {
                        return color(i);
                    })
                    .each(function (d) {
                        this._current = d;
                    })

                let addLegend = () => {
                    console.log('pieData :>> ', pieData);
                    // 更新图例
                    // 移除原有的
                    d3.selectAll('.legend').remove();
                    // 添加新的
                    legend = svg.selectAll(".legend")
                        .data(pieData)
                        .join('g')
                        .attr("class", "legend")
                        .attr("transform", function (d, i) {
                            let x = svgWidth - 100;
                            let y = 20 + i * 25;
                            return "translate(" + x + "," + y + ")";
                        });

                    legend.append("rect")
                        .attr("width", 20)
                        .attr("height", 10)
                        .attr("y", 5)
                        .attr("fill", function (d, i) {
                            return color(i);
                        });

                    texts = legend.append("text")
                        .attr("x", 30)
                        .attr("y", 15)
                        .text(function (d) {
                            return d.data.name + "：" + d.data.value;
                        });
                }
                addLegend();

                let innerHtml = ['更新数据', '正向排序', '反向排序', '添加数据', '删除数据'];
                let buts = [];
                let butdiv = document.createElement('div');
                dom.appendChild(butdiv);
                innerHtml.map(item => {
                    let but = document.createElement('button');
                    but.innerHTML = item;
                    butdiv.appendChild(but);
                    buts.push(but);
                })

                buts[0].onclick = function () {
                    // 生成新的随机数据
                    dataset.forEach(item => {
                        item.value = Math.random() * 90 | 0 + 10;
                    })
                    pieLayout.sort(null);
                    // 生成新的饼图数据
                    pieData = pieLayout(dataset);
                    // 计算过渡状态的函数
                    let arcTween = function (d, i) {
                        let interpolate = d3.interpolate(this._current, pieData[i]);
                        this._current = interpolate(0);
                        return function (t) {
                            return arcGenerator(interpolate(t));
                        };
                    };

                    // 更新饼图数据
                    piePaths = pieContainer.selectAll(".arc")
                        .data(pieData)
                        .join("path")
                        .attr("class", "arc")
                        .attr("d", arcGenerator)
                        .attr("fill", function (d, i) {
                            return color(i);
                        })
                    // .each(function (d) {
                    //     this._current = d;
                    // })


                    // 添加过渡动画
                    piePaths.transition()
                        .duration(1000)
                        .attrTween("d", arcTween);

                    // 更新图例 texts
                    addLegend();

                }

                buts[1].onclick = function () {
                    // 正向排序
                    pieLayout.sort(function (a, b) {
                        return a.value - b.value;
                    });
                    dataset.sort(function (a, b) {
                        return a.value - b.value;
                    });
                    // 生成新的饼图数据
                    pieData = pieLayout(dataset);

                    // 计算过渡状态的函数
                    let arcTween = function (d, i) {
                        let interpolate = d3.interpolate(this._current, pieData[i]);
                        this._current = interpolate(0);
                        return function (t) {
                            return arcGenerator(interpolate(t));
                        };
                    };

                    // 更新饼图数据
                    piePaths = pieContainer.selectAll(".arc")
                        .data(pieData)
                        .join("path")
                        .attr("class", "arc")
                        .attr("d", arcGenerator)
                        .attr("fill", function (d, i) {
                            return color(i);
                        })

                    // 添加过渡动画
                    piePaths.transition()
                        .duration(1000)
                        .attrTween("d", arcTween);

                    // 更新图例 texts
                    addLegend();
                }

                buts[2].onclick = function () {
                    // 反向排序
                    pieLayout.sort(function (a, b) {
                        return b.value - a.value;
                    });
                    dataset.sort(function (a, b) {
                        return b.value - a.value;
                    });
                    console.log('dataset :>> ', dataset);
                    // 生成新的饼图数据
                    pieData = pieLayout(dataset);

                    // 计算过渡状态的函数
                    let arcTween = function (d, i) {
                        let interpolate = d3.interpolate(this._current, pieData[i]);
                        this._current = interpolate(0);
                        return function (t) {
                            return arcGenerator(interpolate(t));
                        };
                    };

                    // 更新饼图数据
                    piePaths = pieContainer.selectAll(".arc")
                        .data(pieData)
                        .join("path")
                        .attr("class", "arc")
                        .attr("d", arcGenerator)
                        .attr("fill", function (d, i) {
                            return color(i);
                        })

                    // 添加过渡动画
                    piePaths.transition()
                        .duration(1000)
                        .attrTween("d", arcTween);

                    // 更新图例 texts
                    addLegend();
                }

                buts[3].onclick = function () {
                    // 生成新的随机数据
                    // 随机生成一个汉字
                    let randomChinese = function () {
                        let str = '';
                        let random = Math.round(Math.random() * 20901) + 19968;
                        str += String.fromCharCode(random);
                        return str;
                    }
                    dataset.push({
                        name: randomChinese(),
                        value: Math.random() * 90 | 0 + 10
                    })
                    // 生成新的饼图数据
                    pieData = pieLayout(dataset);
                    // 计算过渡状态的函数
                    let arcTween = function (d, i) {
                        let interpolate = d3.interpolate(this._current, pieData[i]);
                        this._current = interpolate(0);
                        return function (t) {
                            return arcGenerator(interpolate(t));
                        };
                    };

                    // 更新饼图数据
                    piePaths = pieContainer.selectAll(".arc")
                        .data(pieData)
                        .join("path")
                        .attr("class", "arc")
                        .attr("d", arcGenerator)
                        .attr("fill", function (d, i) {
                            return color(i);
                        })

                    // 添加过渡动画
                    piePaths.transition()
                        .duration(1000)
                        .attrTween("d", arcTween);

                    addLegend();

                }

                buts[4].onclick = function () {
                    if (dataset.length <= 4) {
                        return;
                    }
                    dataset.pop();
                    pieData = pieLayout(dataset);
                    // 计算过渡状态的函数
                    let arcTween = function (d, i) {
                        let interpolate = d3.interpolate(this._current, pieData[i]);
                        this._current = interpolate(0);
                        return function (t) {
                            return arcGenerator(interpolate(t));
                        };
                    };

                    // 更新饼图数据
                    piePaths = pieContainer.selectAll(".arc")
                        .data(pieData)
                        .join("path")
                        .attr("class", "arc")
                        .attr("d", arcGenerator)
                        .attr("fill", function (d, i) {
                            return color(i);
                        })

                    // 添加过渡动画
                    piePaths.transition()
                        .duration(1000)
                        .attrTween("d", arcTween);

                    addLegend();

                }

            })()

    </script>
    <!-- 
    <script>
        // 基本散点图
        let dataset = [];
        for (let i = 0; i < 100; i++) {
            let x = Math.random() * 9 + 1;
            let y = 100 - Math.floor(Math.random() * 90 + 5);
            dataset.push([x, y]);
        }

        let padding = 30;
        let svgWidth = 600;
        let svgHeight = 400;

        let xScale = d3.scaleLinear()
            .domain([0, d3.max(dataset, function (d) { return d[0]; })])
            .range([padding, svgWidth - padding]);

        let yScale = d3.scaleLinear()
            .domain([0, d3.max(dataset, function (d) { return d[1]; })])
            .range([svgHeight - padding, padding]);

        let svg = d3.select("body")
            .append("svg")
            .attr("width", svgWidth)
            .attr("height", svgHeight)
            .style('border', '1px solid #999999')

        let dots = svg.selectAll(".dot")
            .data(dataset)
            .enter().append("circle")
            .attr("class", "dot")
            .attr("r", 5)
            .attr("fill", "#69b3a2")
            .attr("cx", function (d) { return xScale(d[0]); })
            .attr("cy", function (d) { return yScale(d[1]); });

        let xAxis = d3.axisBottom(xScale);
        let yAxis = d3.axisLeft(yScale);

        svg.append("g")
            .attr("class", "x-axis")
            .attr("transform", "translate(0," + (svgHeight - padding) + ")")
            .call(xAxis);

        svg.append("g")
            .attr("class", "y-axis")
            .attr("transform", "translate(" + padding + ",0)")
            .call(yAxis);

    </script>
    <script>
        // 基本雷达图
        // 基本雷达图数据
        let dataset = [
            { name: "数学", value: 98 },
            { name: "语文", value: 90 },
            { name: "英语", value: 80 },
            { name: "物理", value: 85 },
            { name: "化学", value: 85 },
            { name: "生物", value: 90 }
        ];

        // 雷达图属性
        let padding = 50;
        let svgWidth = 600;
        let svgHeight = 400;
        let centerX = svgWidth / 2; // 中心点x坐标
        let centerY = svgHeight / 2; // 中心点y坐标
        let radius = Math.min(centerX, centerY) - padding; // 半径

        // 刻度数量，即多边形共有几个角
        let numTicks = dataset.length;

        // 极坐标系转换函数
        let angleScale = d3.scaleLinear()
            .domain([0, numTicks])
            .range([0, Math.PI * 2]);

        // 线性比例尺转换函数
        let valueScale = d3.scaleLinear()
            .domain([0, 100])
            .range([0, radius]);

        // 创建SVG元素
        let svg = d3.select("body")
            .append("svg")
            .attr("width", svgWidth)
            .attr("height", svgHeight)
            .style('border', '1px solid #999999');

        // 定义渐变 中心向外渐变
        let gradient = svg.append("defs")
            .append("radialGradient")
            .attr("id", "gradient")
            .attr("cx", "50%")
            .attr("cy", "50%")
            .attr("r", "50%")
            .attr("fx", "50%")
            .attr("fy", "50%");
        gradient.append("stop")
            .attr("offset", "0%")
            .attr("stop-color", "#f6efa6")
            .attr("stop-opacity", 1);
        gradient.append("stop")
            .attr("offset", "100%")
            .attr("stop-color", "#69b3a2")
            .attr("stop-opacity", 1);


        // 绘制多边形
        let polygon = svg.append("g")
            .attr("class", "polygon");
        for (let i = 0; i < numTicks; i++) {
            let angle = angleScale(i);
            let x = centerX + valueScale(100) * Math.sin(angle);
            let y = centerY - valueScale(100) * Math.cos(angle);
            polygon.append("line")
                .attr("x1", centerX)
                .attr("y1", centerY)
                .attr("x2", x)
                .attr("y2", y)
                .attr("stroke", "#cccccc")
                .attr("stroke-width", 1);
        }

        // 绘制数据连线
        let line = d3.line()
            .x(function (d, i) { return centerX + valueScale(d.value) * Math.sin(angleScale(i)); })
            .y(function (d, i) { return centerY - valueScale(d.value) * Math.cos(angleScale(i)); });
        svg.append("path")
            .datum(dataset)
            .attr("fill", "url(#gradient)")
            .attr("stroke", "#69b3a2")
            .attr("stroke-width", 2)
            .attr("d", line);

        // 绘制轴标签
        let labels = svg.append("g")
            .attr("class", "labels");
        for (let i = 0; i < numTicks; i++) {
            let angle = angleScale(i);
            let r = radius + padding*0.5;
            let x = centerX + r * Math.sin(angle);
            let y = centerY - r * Math.cos(angle);
            labels.append("text")
                .attr("x", x)
                .attr("y", y)
                .attr("text-anchor", "middle")
                .attr("fill", "#333333")
                .text(dataset[i].name + " " + dataset[i].value);
        }

    </script>
 -->
</body>

</html>